<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SHM Master - ÏúÑÏπò/ÏÜçÎèÑ/Í∞ÄÏÜçÎèÑ ÏãúÎÆ¨Î†àÏù¥ÏÖò</title>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2754252374614527"
    crossorigin="anonymous"></script>
  <meta name="google-adsense-account" content="ca-pub-2754252374614527">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #171717;
      --bg-tertiary: #262626;
      --text-primary: #ededed;
      --text-secondary: #a3a3a3;
      --accent-blue: #3b82f6;
      --accent-green: #10b981;
      --accent-red: #ef4444;
      --accent-purple: #a855f7;
      --grid-color: rgba(255, 255, 255, 0.05);
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
    }

    .app-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    .header {
      margin-bottom: 2rem;
      text-align: left;
    }

    .header h1 {
      margin: 0;
      font-size: 1.8rem;
      background: linear-gradient(to right, #3b82f6, #a855f7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .main-layout {
      display: grid;
      grid-template-columns: 1fr 340px;
      gap: 2rem;
    }

    @media (max-width: 1000px) {
      .main-layout {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--bg-secondary);
      border: 1px solid var(--bg-tertiary);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .sim-view {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    canvas.oscillator-canvas {
      width: 100%;
      height: 240px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
    }

    /* Graphs Grid */
    .graphs-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }

    .graph-item {
      position: relative;
    }

    canvas.graph-canvas {
      width: 100%;
      height: 160px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }

    .graph-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    /* Controls */
    .control-section {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .control-item {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .label-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .val-text {
      font-family: monospace;
      color: var(--accent-blue);
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .btn {
      padding: 0.8rem;
      border-radius: 10px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn-play {
      background: var(--accent-blue);
      color: white;
    }

    .btn-pause {
      background: #f59e0b;
      color: white;
    }

    .btn-reset {
      background: var(--bg-tertiary);
      color: white;
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .dash-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--bg-tertiary);
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
    }

    .dash-val {
      font-size: 1.2rem;
      font-weight: 700;
      font-family: monospace;
    }

    .dash-lbl {
      font-size: 0.6rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      margin-top: 0.2rem;
    }

    /* Contact Form Styles */
    .contact-card {
      margin-top: 1.5rem;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }

    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .form-input,
    .form-textarea {
      background: var(--bg-tertiary);
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 0.75rem;
      color: #fff;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s;
    }

    .form-input:focus,
    .form-textarea:focus {
      border-color: var(--accent-blue);
    }

    .form-textarea {
      resize: vertical;
      min-height: 80px;
    }

    .btn-submit {
      background: linear-gradient(to right, #3b82f6, #a855f7);
      color: white;
      padding: 0.75rem;
      border-radius: 8px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .btn-submit:hover {
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const App = () => {
      // -- Physics State --
      const [params, setParams] = useState({
        m: 1.0,  // kg
        k: 10.0, // N/m
        x0: 2.0, // m
        v0: 0.0  // m/s
      });

      const [time, setTime] = useState(0);
      const [paused, setPaused] = useState(true);
      const requestRef = useRef();
      const lastTimeRef = useRef();

      // -- Physics Calculations --
      const physics = useMemo(() => {
        const omega = Math.sqrt(params.k / params.m);
        const A = Math.sqrt(params.x0 ** 2 + (params.v0 / omega) ** 2);
        const phi = Math.atan2(-params.v0 / omega, params.x0);
        return { omega, A, phi };
      }, [params]);

      const getStates = (t) => {
        const x = physics.A * Math.cos(physics.omega * t + physics.phi);
        const v = -physics.A * physics.omega * Math.sin(physics.omega * t + physics.phi);
        const a = -physics.omega * physics.omega * x;
        return { x, v, a };
      };

      const currentState = getStates(time);

      // -- Animation Loop --
      const animate = (t) => {
        if (lastTimeRef.current !== undefined) {
          const dt = Math.min((t - lastTimeRef.current) / 1000, 0.05);
          setTime(prev => prev + dt);
        }
        lastTimeRef.current = t;
        requestRef.current = requestAnimationFrame(animate);
      };

      useEffect(() => {
        if (!paused) {
          requestRef.current = requestAnimationFrame(animate);
        } else {
          lastTimeRef.current = undefined;
          cancelAnimationFrame(requestRef.current);
        }
        return () => cancelAnimationFrame(requestRef.current);
      }, [paused]);

      // -- Drawing Functions --
      const oscCanvasRef = useRef();
      const xGraphRef = useRef();
      const vGraphRef = useRef();
      const aGraphRef = useRef();

      const drawSimulation = () => {
        const canvas = oscCanvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width;
        const h = rect.height;

        const centerY = h / 2;
        const wallX = 60;
        const eqX = w / 2 + 50;
        const scale = 35;
        const massX = eqX + currentState.x * scale;
        const mSize = 44;

        ctx.clearRect(0, 0, w, h);

        // Floor
        ctx.strokeStyle = '#262626';
        ctx.beginPath(); ctx.moveTo(0, centerY + mSize / 2); ctx.lineTo(w, centerY + mSize / 2); ctx.stroke();

        // Equilibrium Line
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(eqX, 0); ctx.lineTo(eqX, h); ctx.stroke();
        ctx.setLineDash([]);

        // Wall
        ctx.fillStyle = '#333';
        ctx.fillRect(0, centerY - 60, wallX, 120);

        // Spring
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(wallX, centerY);
        const segs = 40;
        const sLen = (massX - mSize / 2) - wallX;
        for (let i = 0; i <= segs; i++) {
          const x = wallX + (sLen * i / segs);
          const y = i === 0 || i === segs ? centerY : centerY + (i % 2 === 0 ? 12 : -12);
          ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Mass
        ctx.fillStyle = '#ef4444';
        ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(239, 68, 68, 0.4)';
        ctx.fillRect(massX - mSize / 2, centerY - mSize / 2, mSize, mSize);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(`x = ${currentState.x.toFixed(2)}m`, massX, centerY - 40);
      };

      const drawGraph = (canvasRef, type, color) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const w = rect.width;
        const h = rect.height;

        const padding = { left: 50, right: 20, top: 20, bottom: 30 };
        const graphW = w - padding.left - padding.right;
        const graphH = h - padding.top - padding.bottom;
        const midY = padding.top + graphH / 2;

        const timeScale = 40; // px / sec
        const timeWindow = graphW / timeScale;
        const startTime = Math.max(0, time - timeWindow * 0.8);

        let theoreticalMax;
        if (type === 'x') theoreticalMax = physics.A;
        else if (type === 'v') theoreticalMax = physics.A * physics.omega;
        else if (type === 'a') theoreticalMax = physics.A * (physics.omega ** 2);

        const safeMax = Math.max(theoreticalMax, 0.1);
        const valScale = (graphH / 2 * 0.8) / safeMax;

        ctx.clearRect(0, 0, w, h);

        // Grid & Background
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const y = padding.top + (graphH * i / 4);
          ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(w - padding.right, y); ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        // X-axis (Time)
        ctx.beginPath(); ctx.moveTo(padding.left, midY); ctx.lineTo(w - padding.right, midY); ctx.stroke();
        // Y-axis (Value)
        ctx.beginPath(); ctx.moveTo(padding.left, padding.top); ctx.lineTo(padding.left, h - padding.bottom); ctx.stroke();

        // Labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '10px Inter';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';

        // Y-Axis Ticks
        const unit = type === 'x' ? 'm' : (type === 'v' ? 'm/s' : 'm/s¬≤');
        ctx.fillText(`${safeMax.toFixed(1)}`, padding.left - 8, midY - safeMax * valScale);
        ctx.fillText(`0`, padding.left - 8, midY);
        ctx.fillText(`-${safeMax.toFixed(1)}`, padding.left - 8, midY + safeMax * valScale);

        // Axis Title
        ctx.save();
        ctx.translate(15, midY);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText(`${type.toUpperCase()} (${unit})`, 0, 0);
        ctx.restore();

        // X-Axis Ticks (Time)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let tLine = Math.ceil(startTime); tLine <= startTime + timeWindow; tLine++) {
          const xPos = padding.left + (tLine - startTime) * timeScale;
          if (xPos >= padding.left && xPos <= w - padding.right) {
            ctx.fillText(`${tLine}s`, xPos, h - padding.bottom + 5);
          }
        }

        // Plot
        ctx.save();
        ctx.beginPath();
        ctx.rect(padding.left, padding.top, graphW, graphH);
        ctx.clip();

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let px = 0; px <= graphW; px++) {
          const t = startTime + (px / timeScale);
          const state = getStates(t);
          const val = state[type];
          const py = midY - val * valScale;
          const xPos = padding.left + px;
          if (px === 0) ctx.moveTo(xPos, py); else ctx.lineTo(xPos, py);
        }
        ctx.stroke();

        // Cursor
        const cursorX = padding.left + (time - startTime) * timeScale;
        if (cursorX >= padding.left && cursorX <= w - padding.right) {
          ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.arc(cursorX, midY - currentState[type] * valScale, 4, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();

        // Current Value
        ctx.fillStyle = color;
        ctx.font = 'bold 11px monospace';
        ctx.textAlign = 'right';
        ctx.fillText(`${currentState[type].toFixed(2)} ${unit}`, w - padding.right, padding.top - 5);
      };

      useEffect(() => {
        drawSimulation();
        drawGraph(xGraphRef, 'x', '#3b82f6');
        drawGraph(vGraphRef, 'v', '#10b981');
        drawGraph(aGraphRef, 'a', '#a855f7');
      }, [time, physics]);

      const updateParam = (key, val) => {
        setParams(prev => ({ ...prev, [key]: val }));
        if (key === 'x0' || key === 'v0') {
          setTime(0);
          setPaused(true);
        }
      };

      return (
        <div className="app-container">
          <header className="header">
            <h1>SHM Master: Interactive Physics</h1>
          </header>

          <div className="main-layout">
            <div className="sim-view card">
              <canvas ref={oscCanvasRef} className="oscillator-canvas"></canvas>

              <div className="graphs-container">
                <div className="graph-item">
                  <div className="graph-label"><div className="dot" style={{ background: '#3b82f6' }}></div> Position (x)</div>
                  <canvas ref={xGraphRef} className="graph-canvas"></canvas>
                </div>
                <div className="graph-item">
                  <div className="graph-label"><div className="dot" style={{ background: '#10b981' }}></div> Velocity (v)</div>
                  <canvas ref={vGraphRef} className="graph-canvas"></canvas>
                </div>
                <div className="graph-item">
                  <div className="graph-label"><div className="dot" style={{ background: '#a855f7' }}></div> Acceleration (a)</div>
                  <canvas ref={aGraphRef} className="graph-canvas"></canvas>
                </div>
              </div>
            </div>

            <aside className="control-section">
              <div className="card">
                <h3 style={{ margin: '0 0 1.5rem 0', fontSize: '1rem' }}>Îß§Í∞úÎ≥ÄÏàò ÏÑ§Ï†ï</h3>

                <div className="control-item">
                  <div className="label-row"><span>Ï¥àÍ∏∞ ÏúÑÏπò (x‚ÇÄ)</span> <span className="val-text">{params.x0.toFixed(1)} m</span></div>
                  <input type="range" min="-4" max="4" step="0.1" value={params.x0} onChange={e => updateParam('x0', parseFloat(e.target.value))} />
                </div>

                <div className="control-item" style={{ marginTop: '10px' }}>
                  <div className="label-row"><span>Ï¥àÍ∏∞ ÏÜçÎèÑ (v‚ÇÄ)</span> <span className="val-text">{params.v0.toFixed(1)} m/s</span></div>
                  <input type="range" min="-10" max="10" step="0.5" value={params.v0} onChange={e => updateParam('v0', parseFloat(e.target.value))} />
                </div>

                <div className="control-item" style={{ marginTop: '10px' }}>
                  <div className="label-row"><span>ÏßàÎüâ (m)</span> <span className="val-text">{params.m.toFixed(1)} kg</span></div>
                  <input type="range" min="0.5" max="5" step="0.1" value={params.m} onChange={e => updateParam('m', parseFloat(e.target.value))} />
                </div>

                <div className="control-item" style={{ marginTop: '10px' }}>
                  <div className="label-row"><span>Ïä§ÌîÑÎßÅ ÏÉÅÏàò (k)</span> <span className="val-text">{params.k} N/m</span></div>
                  <input type="range" min="1" max="50" step="1" value={params.k} onChange={e => updateParam('k', parseFloat(e.target.value))} />
                </div>

                <div className="button-group">
                  <button className={`btn ${paused ? 'btn-play' : 'btn-pause'}`} onClick={() => setPaused(!paused)}>
                    {paused ? "ÏãúÏûë" : "ÏùºÏãúÏ†ïÏßÄ"}
                  </button>
                  <button className="btn btn-reset" onClick={() => { setTime(0); setPaused(true); }}>Ï¥àÍ∏∞Ìôî</button>
                </div>
              </div>

              <div className="dashboard">
                <div className="dash-card">
                  <div className="dash-val">{(2 * Math.PI / physics.omega).toFixed(2)}s</div>
                  <div className="dash-lbl">Period (T)</div>
                </div>
                <div className="dash-card">
                  <div className="dash-val">{physics.omega.toFixed(2)}</div>
                  <div className="dash-lbl">Freq (œâ)</div>
                </div>
                <div className="dash-card">
                  <div className="dash-val">{(0.5 * params.k * currentState.x ** 2 + 0.5 * params.m * currentState.v ** 2).toFixed(1)}J</div>
                  <div className="dash-lbl">Energy (E)</div>
                </div>
                <div className="dash-card">
                  <div className="dash-val">{physics.A.toFixed(2)}m</div>
                  <div className="dash-lbl">Amplitude (A)</div>
                </div>
              </div>

              {/* Ï†úÌú¥ Î¨∏Ïùò Ìèº */}
              <div className="card contact-card">
                <h3 style={{ margin: '0 0 1rem 0', fontSize: '1rem', color: 'var(--accent-blue)' }}>ü§ù Ï†úÌú¥ Î¨∏Ïùò</h3>
                <p style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>
                  ÏãúÎÆ¨Î†àÏù¥ÏÖò ÎèÑÏûÖ Î∞è ÌòëÏóÖ Î¨∏ÏùòÎäî ÏïÑÎûò ÌèºÏùÑ ÌÜµÌï¥ ÎÇ®Í≤®Ï£ºÏÑ∏Ïöî.
                </p>
                <form action="https://formspree.io/f/xvzzpqdq" method="POST" className="contact-form">
                  <input type="text" name="name" className="form-input" placeholder="ÏÑ±Ìï®/Í∏∞ÏóÖÎ™Ö" required />
                  <input type="email" name="email" className="form-input" placeholder="Ïù¥Î©îÏùº Ï£ºÏÜå" required />
                  <textarea name="message" className="form-textarea" placeholder="Î¨∏Ïùò ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî." required></textarea>
                  <button type="submit" className="btn-submit">Î¨∏Ïùò Î≥¥ÎÇ¥Í∏∞</button>
                </form>
              </div>
            </aside>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>

</html>