<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHM Master - 위치/속도/가속도 시뮬레이션</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #171717;
            --bg-tertiary: #262626;
            --text-primary: #ededed;
            --text-secondary: #a3a3a3;
            --accent-blue: #3b82f6;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-purple: #a855f7;
            --grid-color: rgba(255, 255, 255, 0.05);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            margin-bottom: 2rem;
            text-align: left;
        }

        .header h1 {
            margin: 0;
            font-size: 1.8rem;
            background: linear-gradient(to right, #3b82f6, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 2rem;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--bg-tertiary);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .sim-view {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        canvas.oscillator-canvas {
            width: 100%;
            height: 240px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
        }

        /* Graphs Grid */
        .graphs-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        canvas.graph-canvas {
            width: 100%;
            height: 140px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .graph-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* Controls */
        .control-section {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .label-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .val-text {
            font-family: monospace;
            color: var(--accent-blue);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .btn {
            padding: 0.8rem;
            border-radius: 10px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn-play {
            background: var(--accent-blue);
            color: white;
        }

        .btn-pause {
            background: #f59e0b;
            color: white;
        }

        .btn-reset {
            background: var(--bg-tertiary);
            color: white;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .dash-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--bg-tertiary);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
        }

        .dash-val {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: monospace;
        }

        .dash-lbl {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 0.2rem;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const App = () => {
            // -- Physics State --
            const [params, setParams] = useState({
                m: 1.0,  // kg
                k: 10.0, // N/m
                x0: 2.0, // m
                v0: 0.0  // m/s
            });

            const [time, setTime] = useState(0);
            const [paused, setPaused] = useState(true);
            const requestRef = useRef();
            const lastTimeRef = useRef();

            // -- Physics Calculations --
            // ω = sqrt(k/m)
            // x(t) = A cos(ωt + φ)
            // v(t) = -Aω sin(ωt + φ)
            // a(t) = -Aω² cos(ωt + φ) = -ω²x(t)

            const physics = useMemo(() => {
                const omega = Math.sqrt(params.k / params.m);
                // A cos(phi) = x0
                // -A*omega*sin(phi) = v0 -> A sin(phi) = -v0/omega
                const A = Math.sqrt(params.x0 ** 2 + (params.v0 / omega) ** 2);
                const phi = Math.atan2(-params.v0 / omega, params.x0);
                return { omega, A, phi };
            }, [params]);

            const getStates = (t) => {
                const x = physics.A * Math.cos(physics.omega * t + physics.phi);
                const v = -physics.A * physics.omega * Math.sin(physics.omega * t + physics.phi);
                const a = -physics.omega * physics.omega * x;
                return { x, v, a };
            };

            const currentState = getStates(time);

            // -- Animation Loop --
            const animate = (t) => {
                if (lastTimeRef.current !== undefined) {
                    const dt = Math.min((t - lastTimeRef.current) / 1000, 0.05);
                    setTime(prev => prev + dt);
                }
                lastTimeRef.current = t;
                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                if (!paused) {
                    requestRef.current = requestAnimationFrame(animate);
                } else {
                    lastTimeRef.current = undefined;
                    cancelAnimationFrame(requestRef.current);
                }
                return () => cancelAnimationFrame(requestRef.current);
            }, [paused]);

            // -- Drawing Functions --
            const oscCanvasRef = useRef();
            const xGraphRef = useRef();
            const vGraphRef = useRef();
            const aGraphRef = useRef();

            const drawSimulation = () => {
                const canvas = oscCanvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width = canvas.offsetWidth;
                const h = canvas.height = canvas.offsetHeight;

                const centerY = h / 2;
                const wallX = 60;
                const eqX = w / 2 + 50; // Equilibrium X
                const scale = 35; // px / m
                const massX = eqX + currentState.x * scale;
                const mSize = 44;

                ctx.clearRect(0, 0, w, h);

                // Floor
                ctx.strokeStyle = '#262626';
                ctx.beginPath(); ctx.moveTo(0, centerY + mSize / 2); ctx.lineTo(w, centerY + mSize / 2); ctx.stroke();

                // Equilibrium Line
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(eqX, 0); ctx.lineTo(eqX, h); ctx.stroke();
                ctx.setLineDash([]);

                // Wall
                ctx.fillStyle = '#333';
                ctx.fillRect(0, centerY - 60, wallX, 120);

                // Spring
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(wallX, centerY);
                const segs = 40;
                const sLen = (massX - mSize / 2) - wallX;
                for (let i = 0; i <= segs; i++) {
                    const x = wallX + (sLen * i / segs);
                    const y = i === 0 || i === segs ? centerY : centerY + (i % 2 === 0 ? 12 : -12);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Mass
                ctx.fillStyle = '#ef4444';
                ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(239, 68, 68, 0.4)';
                ctx.fillRect(massX - mSize / 2, centerY - mSize / 2, mSize, mSize);
                ctx.shadowBlur = 0;

                // Value Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`x = ${currentState.x.toFixed(2)}m`, massX, centerY - 40);
            };

            const drawGraph = (canvasRef, type, color) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width = canvas.offsetWidth;
                const h = canvas.height = canvas.offsetHeight;

                const midY = h / 2;
                const timeScale = 40; // px / sec

                // Calculate dynamic scale based on theoretical max for this specific movement
                let theoreticalMax;
                if (type === 'x') theoreticalMax = physics.A;
                else if (type === 'v') theoreticalMax = physics.A * physics.omega;
                else if (type === 'a') theoreticalMax = physics.A * (physics.omega ** 2);

                // Ensure we have a minimum "zoom" even for small oscillations
                const safeMax = Math.max(theoreticalMax, 0.1);
                // valScale converts meters (or m/s, m/s2) to pixels. 
                // We want safeMax * valScale = midY * 0.8 (to leave 20% top/bottom padding)
                const valScale = (midY * 0.8) / safeMax;

                ctx.clearRect(0, 0, w, h);

                // Axis
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.moveTo(0, midY); ctx.lineTo(w, midY); ctx.stroke();

                // Plot
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                const timeWindow = w / timeScale;
                const startTime = Math.max(0, time - timeWindow * 0.8);

                for (let px = 0; px < w; px++) {
                    const t = startTime + (px / timeScale);
                    const state = getStates(t);
                    const val = state[type];
                    const py = midY - val * valScale;
                    if (px === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Current Value Tag (Floating text)
                ctx.fillStyle = color;
                ctx.font = '10px monospace';
                ctx.textAlign = 'right';
                const unit = type === 'x' ? 'm' : (type === 'v' ? 'm/s' : 'm/s²');
                ctx.fillText(`${currentState[type].toFixed(2)}${unit}`, w - 10, 20);

                // Current Time Cursor
                const cursorX = (time - startTime) * timeScale;
                if (cursorX >= 0 && cursorX <= w) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(cursorX, midY - currentState[type] * valScale, 4, 0, Math.PI * 2); ctx.fill();
                }
            };

            useEffect(() => {
                drawSimulation();
                drawGraph(xGraphRef, 'x', '#3b82f6');
                drawGraph(vGraphRef, 'v', '#10b981');
                drawGraph(aGraphRef, 'a', '#a855f7');
            }, [time, physics]);

            const updateParam = (key, val) => {
                setParams(prev => ({ ...prev, [key]: val }));
                // Reset time when changing initial conditions to see proper start
                if (key === 'x0' || key === 'v0') {
                    setTime(0);
                    setPaused(true);
                }
            };

            return (
                <div className="app-container">
                    <header className="header">
                        <h1>SHM Master: Interactive Physics</h1>
                    </header>

                    <div className="main-layout">
                        {/* Simulation & Graphs */}
                        <div className="sim-view card">
                            <canvas ref={oscCanvasRef} className="oscillator-canvas"></canvas>

                            <div className="graphs-container">
                                <div>
                                    <div className="graph-label"><div className="dot" style={{ background: '#3b82f6' }}></div> Position (x)</div>
                                    <canvas ref={xGraphRef} className="graph-canvas"></canvas>
                                </div>
                                <div>
                                    <div className="graph-label"><div className="dot" style={{ background: '#10b981' }}></div> Velocity (v)</div>
                                    <canvas ref={vGraphRef} className="graph-canvas"></canvas>
                                </div>
                                <div>
                                    <div className="graph-label"><div className="dot" style={{ background: '#a855f7' }}></div> Acceleration (a)</div>
                                    <canvas ref={aGraphRef} className="graph-canvas"></canvas>
                                </div>
                            </div>
                        </div>

                        {/* Controls */}
                        <aside className="control-section">
                            <div className="card">
                                <h3 style={{ margin: '0 0 1.5rem 0', fontSize: '1rem' }}>매개변수 설정</h3>

                                <div className="control-item">
                                    <div className="label-row"><span>초기 위치 (x₀)</span> <span className="val-text">{params.x0.toFixed(1)} m</span></div>
                                    <input type="range" min="-4" max="4" step="0.1" value={params.x0} onChange={e => updateParam('x0', parseFloat(e.target.value))} />
                                </div>

                                <div className="control-item" style={{ marginTop: '10px' }}>
                                    <div className="label-row"><span>초기 속도 (v₀)</span> <span className="val-text">{params.v0.toFixed(1)} m/s</span></div>
                                    <input type="range" min="-10" max="10" step="0.5" value={params.v0} onChange={e => updateParam('v0', parseFloat(e.target.value))} />
                                </div>

                                <div className="control-item" style={{ marginTop: '10px' }}>
                                    <div className="label-row"><span>질량 (m)</span> <span className="val-text">{params.m.toFixed(1)} kg</span></div>
                                    <input type="range" min="0.5" max="5" step="0.1" value={params.m} onChange={e => updateParam('m', parseFloat(e.target.value))} />
                                </div>

                                <div className="control-item" style={{ marginTop: '10px' }}>
                                    <div className="label-row"><span>스프링 상수 (k)</span> <span className="val-text">{params.k} N/m</span></div>
                                    <input type="range" min="1" max="50" step="1" value={params.k} onChange={e => updateParam('k', parseFloat(e.target.value))} />
                                </div>

                                <div className="button-group">
                                    <button className={`btn ${paused ? 'btn-play' : 'btn-pause'}`} onClick={() => setPaused(!paused)}>
                                        {paused ? "시작" : "일시정지"}
                                    </button>
                                    <button className="btn btn-reset" onClick={() => { setTime(0); setPaused(true); }}>초기화</button>
                                </div>
                            </div>

                            <div className="dashboard">
                                <div className="dash-card">
                                    <div className="dash-val">{(2 * Math.PI / physics.omega).toFixed(2)}s</div>
                                    <div className="dash-lbl">Period (T)</div>
                                </div>
                                <div className="dash-card">
                                    <div className="dash-val">{physics.omega.toFixed(2)}</div>
                                    <div className="dash-lbl">Freq (ω)</div>
                                </div>
                                <div className="dash-card">
                                    <div className="dash-val">{(0.5 * params.k * currentState.x ** 2 + 0.5 * params.m * currentState.v ** 2).toFixed(1)}J</div>
                                    <div className="dash-lbl">Energy (E)</div>
                                </div>
                                <div className="dash-card">
                                    <div className="dash-val">{physics.A.toFixed(2)}m</div>
                                    <div className="dash-lbl">Amplitude (A)</div>
                                </div>
                            </div>
                        </aside>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>